(use gauche.collection)
(use data.random)
;;(use scheme.list)
(use srfi-1)

(define (transpose X)
  (apply zip X))

(define (normalize X)
  (let ((M (apply max X)) (m (apply min X)))
    (map (lambda (x) (/ (- x m) (- M m))) X)))

(define (normalize-features X)
  (let* ((X-trans (transpose X))
         (X-normalized-trans (map normalize X-trans)))
    (transpose X-normalized-trans)))

(define (categorize-string-class X)
  (define (create-category-assoc X)
    (define (create-category-assoc-i X a)
      (if (null? X)
        a
        (let ((key (car X)) (cdr-X (cdr X)))
          (if (not (assq key a))
            (create-category-assoc-i cdr-X (cons (cons key (+ 1 (cdar a))) a))
            (create-category-assoc-i cdr-X a)))))
    (create-category-assoc-i (cdr X) (list (cons (car X) 0))))
  (let* ((X-symbols (map string->symbol X))
         (assc (create-category-assoc X-symbols)))
    (map (lambda (x) (cdr (assq x assc))) X-symbols)))

(define (proportional-train-test-split ratio X y)
  (let* ((yX (zip y X))
         (yX-grouped (group-collection yX :key car))
         (yX-grouped-split (map (lambda (l)
                                  (receive (lf ll)
                                           (split-at l (floor (* ratio (length l))))
                                           (list lf ll)))
                                yX-grouped))
         (yX-split-zipped (transpose yX-grouped-split))
         (yX-zipped (map (lambda (l) (apply append l)) yX-split-zipped))
         (yX-split (apply append (map transpose yX-zipped))))
    (apply values (reverse yX-split))))

(define (unit-vector n i)
  (define (boolean->integer b)
    (if b 1 0))
  (map (lambda (x) (boolean->integer (eq? x i))) (iota n)))

(define (eye n)
  (map (lambda (i) (unit-vector n i)) (iota n)))

(define (encode-one-hot X)
  (define (create-category-list X)
    (map car (group-collection X)))
  (let* ((categories (create-category-list X))
         (I (eye (length categories)))
         (assc (map cons categories I)))
    (map (lambda (x) (cdr (assq x assc))) X)))

(define (dot A B)
  (map (lambda (a) (map (lambda (b) (apply + (map * a b))) (transpose B))) A))

(define (softmax zs)
  (let* ((zs-exp (map exp zs))
         (zs-exp-sum (apply + zs-exp)))
    (map (lambda (z-exp) (/ z-exp zs-exp-sum)) zs-exp)))

(define (multiply-scalar-matrix x A)
  (map (lambda (l) (map (lambda (a) (* x a)) l)) A))

(define (add-matrix A B)
  (map (lambda (a b) (map + a b)) A B))

(define (sub-matrix A B)
  (add-matrix A (multiply-scalar-matrix -1 B)))

(define (argmax l)
  (define (argmax-i l M i a)
    (if (null? l)
      a
      (let ((car-l (car l))
            (cdr-l (cdr l))
            (i+1 (+ 1 i)))
        (if (< M car-l)
          (argmax-i cdr-l car-l i+1 i)
          (argmax-i cdr-l M i+1 a)))))
  (argmax-i (cdr l) (car l) 1 0))

(define (create-SGD n-input n-output :key eta [eta 0.1] var [var 0.1] alpha [alpha 0.1])
  (let* ((theta (let ((randn (reals-normal$ 0 var)))
                  (map (lambda (x) (map (lambda (x) (randn)) (iota n-input))) (iota n-output))))
         (get-theta (lambda () theta))
         (get-alpha (lambda () alpha))
         (set-theta! (lambda (new-theta) (set! theta new-theta)))
         (predict-proba (lambda (X) (map softmax (dot X (transpose theta)))))
         (predict (lambda (X)
                    (map (lambda (x) (unit-vector (length x) (argmax x))) (predict-proba X))))
         (fit (lambda (X y)
                (let* ((m (length X))
                       (p-hat (predict-proba X))
                       (p-y (sub-matrix p-hat y))
                       (grads (add-matrix (multiply-scalar-matrix (/ 1 m) (dot (transpose p-y) X)) (multiply-scalar-matrix alpha (map (lambda (l) (cons 0 (cdr l))) theta)))))
                  (set! theta (sub-matrix theta (multiply-scalar-matrix eta grads))))))
         (method-list (list (cons 'predict-proba predict-proba)
                            (cons 'predict predict)
                            (cons 'fit fit)
                            (cons 'get-alpha get-alpha)
                            (cons 'get-theta get-theta)
                            (cons 'set-theta! set-theta!))))
    (lambda (method)
      (cdr (assq method method-list)))))

(define (cross-entropy-error y-hat y)
  (let ((m (length y)))
    (- (/ (apply + (map (lambda (a b) (apply + (map * a b))) y (map (lambda (l) (map (lambda (x) (log (+ x 1e-7))) l)) y-hat))) m))))
