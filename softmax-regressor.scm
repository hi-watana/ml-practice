(use gauche.collection)
(use data.random)

(define (transpose X)
  (apply map (cons list X)))

(define (normalize X)
  (let ((M (apply max X)) (m (apply min X)))
    (map (lambda (x) (/ (- x m) (- M m))) X)))

(define (normalize-features X)
  (let* ((X-trans (transpose X))
         (X-normalized-trans (map normalize X-trans)))
    (transpose X-normalized-trans)))

(define (categorize-string-class X)
  (define (create-category-assoc X)
    (define (create-category-assoc-i X a)
      (if (null? X)
        a
        (let ((key (car X)) (cdr-X (cdr X)))
          (if (not (assq key a))
            (create-category-assoc-i cdr-X (cons (cons key (+ 1 (cdar a))) a))
            (create-category-assoc-i cdr-X a)))))
    (create-category-assoc-i (cdr X) (list (cons (car X) 0))))
  (let* ((X-symbols (map string->symbol X))
         (assc (create-category-assoc X-symbols)))
    (map (lambda (x) (cdr (assq x assc))) X-symbols)))

(define (proportional-train-test-split ratio X y)
  (define (divide n l)
    (define (divide-i n lf-rev ll)
      (if (zero? n)
        (values (reverse lf-rev) ll)
        (divide-i (- n 1) (cons (car ll) lf-rev) (cdr ll))))
    (divide-i n '() l))
  (let* ((l (group-collection (map list X y) :key cadr))
         (l2 (apply map (cons append 
                              (map (lambda (l) (receive (lf ll)
                                                        (divide (inexact->exact (floor (* ratio (length l)))) l)
                                                        (list lf ll)))
                                   l)))))
    (receive (X-test y-test X-train y-train) (apply values (apply append (map (lambda (l) (transpose l)) l2)))
             (values X-train y-train X-test y-test))))

(define (eye n)
  (define (boolean->integer b)
    (if b 1 0))
  (let ((zero-to-n-1 (iota n 0)))
    (map (lambda (i l) (map (lambda (x) (boolean->integer (eq? x i))) l))
         zero-to-n-1
         (map (lambda (x) zero-to-n-1) zero-to-n-1))))

(define (encode-one-hot X)
  (define (create-category-list X)
    (map car (group-collection X)))
  (let* ((categories (create-category-list X))
         (I (eye (length categories)))
         (assc (map cons categories I)))
    (map (lambda (x) (cdr (assq x assc))) X)))

(define (dot A B)
  (map (lambda (a) (map (lambda (b) (apply + (map * a b))) (transpose B))) A))

(define (softmax zs)
  (let* ((zs-exp (map exp zs))
         (zs-exp-sum (apply + zs-exp)))
    (map (lambda (z-exp) (/ z-exp zs-exp-sum)) zs-exp)))

(define (multiply-scalar-matrix x A)
  (map (lambda (l) (map (lambda (a) (* x a)) l)) A))

(define (add-matrix A B)
  (map (lambda (a b) (map + a b)) A B))

(define (sub-matrix A B)
  (add-matrix A (multiply-scalar-matrix -1 B)))

(define (create-SGD n-input n-output :key eta [eta 0.1] var [var 0.1] alpha [alpha 0.1])
  (let* ((theta (let ((randn (reals-normal$ 0 var)))
                  (map (lambda (x) (map (lambda (x) (randn)) (iota n-input))) (iota n-output))))
         (get-theta (lambda () theta))
         (get-alpha (lambda () alpha))
         (set-theta! (lambda (new-theta) (set! theta new-theta)))
         (predict-proba (lambda (X) (map softmax (dot X (transpose theta)))))
         (fit (lambda (X y)
                (let* ((m (length X))
                       (p-hat (predict-proba X))
                       (p-y (sub-matrix p-hat y))
                       (grads (add-matrix (multiply-scalar-matrix (/ 1 m) (dot (transpose p-y) X)) (multiply-scalar-matrix alpha (map (lambda (l) (cons 0 (cdr l))) theta)))))
                  (set! theta (sub-matrix theta (multiply-scalar-matrix eta grads))))))
         (method-list (list (cons 'predict-proba predict-proba)
                            (cons 'fit fit)
                            (cons 'get-alpha get-alpha)
                            (cons 'get-theta get-theta)
                            (cons 'set-theta! set-theta!))))
    (lambda (method)
      (cdr (assq method method-list)))))

(define (cross-entropy-error y-hat y)
  (let ((m (length y)))
    (- (/ (apply + (map (lambda (a b) (apply + (map * a b))) y (map (lambda (l) (map (lambda (x) (log (+ x 1e-7))) l)) y-hat))) m))))
