(use rfc.http)
(use text.csv)
(use file.util)
(use srfi-1)

(load "./softmax-regressor.scm")

(define num-features 784)
(define num-class 10)
(define eta 0.1)
(define alpha 0.1)
(define batch-size 100)

(define (download-mnist :key type [type 'both])
  (for-each (lambda (csv-name)
              (receive (status header body)
                       (http-get "pjreddie.com" (string-join (list "/media/files/" csv-name) ""))
                       (with-output-to-file csv-name
                                            (lambda () (display body)))))
            (if (eq? type 'train)
              (list "mnist_train.csv")
              (if (eq? type 'train)
                (list "mnist_test.csv")
                (list "mnist_train.csv" "mnist_test.csv"))
              )))


(define (load-mnist :key normalize [normalize #t] one-hot-label [one-hot-label #f])
  (define one-hot-label-list (map cons (iota num-class) (eye num-class)))
  (define (read-csv file-name)
    (call-with-input-file
      file-name
      (cut port->list (make-csv-reader #\,) <>)))
  (define (load-data file-name)
    (let* ((rows (map (lambda (l) (map string->number l)) (read-csv file-name)))
           (X-y-pairs (map (lambda (l)
                             (let ((X (cdr l))
                                   (y (car l)))
                               (list (if normalize
                                       (map (lambda (x) (exact->inexact (/ x 255))) X)
                                       X)
                                     (if one-hot-label (cdr (assq y one-hot-label-list)) y)
                                     )))
                           rows))
           (X-y (apply zip X-y-pairs)))
      (apply values X-y)))
  (receive
    (X-train y-train)
    (load-data "./mnist_train.csv")
    (receive
      (X-test y-test)
      (load-data "./mnist_test.csv")
      (values X-train y-train X-test y-test))))


(define (main args)
  (define (load-train-val-test)
    (receive
      (X-train-val y-train-val X-test y-test)
      (load-mnist :one-hot-label #t)
      (let* ((add-bias (lambda (mat)
                         (map (lambda (l) (cons 1 l)) mat)))
             (X-train-val-with-bias (add-bias X-train-val))
             (X-test-with-bias (add-bias X-test)))
        (receive
          (X-train-with-bias y-train X-val-with-bias y-val)
          (proportional-train-test-split 0.1 X-train-val-with-bias y-train-val)
          (values X-train-with-bias y-train X-val-with-bias y-val X-test-with-bias y-test)))))

  (cond ((not (file-is-readable? "./mnist_train.csv"))
         (print "Downloading mnist_train.csv ...")
         (download-mnist :type 'train)
         (print "Finished.")))
  (cond ((not (file-is-readable? "./mnist_test.csv"))
         (print "Downloading mnist_test.csv ...")
         (download-mnist :type 'test)
         (print "Finished.")))
  (print "Load MNIST ...")
  (receive
    (X-train-with-bias y-train X-val-with-bias y-val X-test-with-bias y-test)
    (load-train-val-test)
    (print "Finished.")
    (let ((model (create-mini-batch-SGD (create-SGD (+ 1 num-features) num-class :eta eta :var 1 :alpha alpha) batch-size))
          (minimum-val-error +inf.0)
          (best-epoch 0)
          (best-model (create-SGD (+ 1 num-features) num-class :eta eta :var 1 :alpha alpha)))
      (for-each
        (lambda (epoch)
          ((model 'fit) X-train-with-bias y-train)
          (let* ((l2-loss (* 0.5 alpha (apply + (map (lambda (l) (apply + (map (lambda (x) (* x x)) (cdr l)))) ((((model 'get-base-model)) 'get-theta))))))
                 (p-val-predict ((model 'predict-proba) X-val-with-bias))
                 (val-error (+ (cross-entropy-error p-val-predict y-val) l2-loss)))
            ;;;(cond ((zero? (modulo epoch 50)) (print "Epoch: " epoch ", Train loss: " train-error ", Validation loss: " val-error)))
            (print "Epoch: " epoch ", Validation loss: " val-error)
            (cond ((< val-error minimum-val-error)
                   (set! minimum-val-error val-error)
                   (set! best-epoch epoch)
                   ((best-model 'set-theta!) ((((model 'get-base-model)) 'get-theta)))
                   ))))
        (iota 30 1))
      (print "----------------------------")
      (let* ((l2-loss (* 0.5 alpha (apply + (map (lambda (l) (apply + (map (lambda (x) (* x x)) (cdr l)))) ((best-model 'get-theta))))))
             (p-val-predict ((best-model 'predict-proba) X-val-with-bias))
             (val-error (+ (cross-entropy-error p-val-predict y-val) l2-loss)))
        (print "Best epoch: " best-epoch ", Validation loss: " val-error))
      (print "----------------------------")
      (let* ((y-test-predict ((best-model 'predict) X-test-with-bias))
             (num-true (length (filter (lambda (x) x) (map equal? y-test-predict y-test))))
             (accuracy (exact->inexact (/ num-true (length y-test)))))
        (print "Accuracy (test): " accuracy)))) 0)
