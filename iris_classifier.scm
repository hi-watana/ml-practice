(use text.csv)
(use gauche.collection)
(use data.random)

(define (solve file-name)
  (cdr (call-with-input-file file-name
	(cut port->list (make-csv-reader #\,) <>)
	:encoding 'utf8)))

(define (transpose X)
  (apply map (cons list X)))

(define (normalize X)
  (let ((M (apply max X)) (m (apply min X)))
    (map (lambda (x) (/ (- x m) (- M m))) X)))

(define (normalize-features X)
  (let* ((X-trans (transpose X))
         (X-normalized-trans (map normalize X-trans)))
    (transpose X-normalized-trans)))

(define (load-iris file-name)
  (let* ((table (solve file-name))
         (l-rev (reverse (transpose table)))
         (y (car l-rev))
         (X (transpose (map (lambda (l) (map string->number l)) (reverse (cdr l-rev))))))
    (values X y)))

(define (categorize-string-class X)
  (define (create-category-assoc X)
    (define (create-category-assoc-i X a)
      (if (null? X)
        a
        (let ((key (car X)) (cdr-X (cdr X)))
          (if (not (assq key a))
            (create-category-assoc-i cdr-X (cons (cons key (+ 1 (cdar a))) a))
            (create-category-assoc-i cdr-X a)))))
    (create-category-assoc-i (cdr X) (list (cons (car X) 0))))
  (let* ((X-symbols (map string->symbol X))
         (assc (create-category-assoc X-symbols)))
    (map (lambda (x) (cdr (assq x assc))) X-symbols)))

(define (proportional-train-test-split ratio X y)
  (define (divide n l)
    (define (divide-i n lf-rev ll)
      (if (zero? n)
        (values (reverse lf-rev) ll)
        (divide-i (- n 1) (cons (car ll) lf-rev) (cdr ll))))
    (divide-i n '() l))
  (let* ((l (group-collection (map list X y) :key cadr))
         (l2 (apply map (cons append 
                              (map (lambda (l) (receive (lf ll)
                                                        (divide (inexact->exact (floor (* ratio (length l)))) l)
                                                        (list lf ll)))
                                   l)))))
    (receive (X-test y-test X-train y-train) (apply values (apply append (map (lambda (l) (transpose l)) l2)))
             (values X-train y-train X-test y-test))))

(define (eye n)
  (define (boolean->integer b)
    (if b 1 0))
  (let ((zero-to-n-1 (iota n 0)))
    (map (lambda (i l) (map (lambda (x) (boolean->integer (eq? x i))) l))
         zero-to-n-1
         (map (lambda (x) zero-to-n-1) zero-to-n-1))))

(define (encode-one-hot X)
  (define (create-category-list X)
    (map car (group-collection X)))
  (let* ((categories (create-category-list X))
         (I (eye (length categories)))
         (assc (map cons categories I)))
    (map (lambda (x) (cdr (assq x assc))) X)))

(define (dot A B)
  (map (lambda (a) (map (lambda (b) (apply + (map * a b))) (transpose B))) A))

(define (softmax zs)
  (let* ((zs-exp (map exp zs))
         (zs-exp-sum (apply + zs-exp)))
    (map (lambda (z-exp) (/ z-exp zs-exp-sum)) zs-exp)))

(define (multiply-scalar-matrix x A)
  (map (lambda (l) (map (lambda (a) (* x a)) l)) A))

(define (add-matrix A B)
  (map (lambda (a b) (map + a b)) A B))

(define (sub-matrix A B)
  (add-matrix A (multiply-scalar-matrix -1 B)))

(define (create-SGD n-input n-output :key eta [eta 0.1] var [var 0.1] alpha [alpha 0.1])
  (let* ((theta (let ((randn (reals-normal$ 0 var)))
                  (map (lambda (x) (map (lambda (x) (randn)) (iota n-input))) (iota n-output))))
         (get-theta (lambda () theta))
         (get-alpha (lambda () alpha))
         (set-theta! (lambda (new-theta) (set! theta new-theta)))
         (predict-proba (lambda (X) (map softmax (dot X (transpose theta)))))
         (fit (lambda (X y)
                (let* ((m (length X))
                       (p-hat (predict-proba X))
                       (p-y (sub-matrix p-hat y))
                       (grads (add-matrix (multiply-scalar-matrix (/ 1 m) (dot (transpose p-y) X)) (multiply-scalar-matrix alpha (map (lambda (l) (cons 0 (cdr l))) theta)))))
                  (set! theta (sub-matrix theta (multiply-scalar-matrix eta grads))))))
         (method-list (list (cons 'predict-proba predict-proba)
                            (cons 'fit fit)
                            (cons 'get-alpha get-alpha)
                            (cons 'get-theta get-theta)
                            (cons 'set-theta! set-theta!))))
    (lambda (method)
      (cdr (assq method method-list)))))

(define (cross-entropy-error y-hat y)
  (let ((m (length y)))
    (- (/ (apply + (map (lambda (a b) (apply + (map * a b))) y (map (lambda (l) (map (lambda (x) (log (+ x 1e-7))) l)) y-hat))) m))))

(define (main args)
  (receive
    (X y)
    (load-iris "iris.csv")
    (let* ((y-label (categorize-string-class y))
           (y-one-hot (encode-one-hot y-label))
           (X-normalized (normalize-features X))
           (X-with-bias (map (lambda (l) (cons 1 l)) X-normalized))
           (model (create-SGD (length (car X-with-bias)) (length (car y-one-hot)) :eta 0.1 :var 1 :alpha 0.005))
           (minimum-val-error +inf.0)
           (best-epoch 0)
           (best-model (create-SGD (length (car X-with-bias)) (length (car y-one-hot)) :eta 0.1 :var 1 :alpha 0.005)))
      (receive
        (X-train-val y-train-val X-test y-test)
        (proportional-train-test-split 0.2 X-with-bias y-one-hot)
        (receive
          (X-train y-train X-val y-val)
          (proportional-train-test-split 0.25 X-train-val y-train-val)
          (for-each
            (lambda (epoch)
              ((model 'fit) X-train y-train)
              (let* ((l2-loss (* 0.5 ((model 'get-alpha)) (apply + (map (lambda (l) (apply + (map (lambda (x) (* x x)) (cdr l)))) ((model 'get-theta))))))
                     (p-train-predict ((model 'predict-proba) X-train))
                     (p-val-predict ((model 'predict-proba) X-val))
                     (train-error (+ (cross-entropy-error p-train-predict y-train) l2-loss))
                     (val-error (+ (cross-entropy-error p-val-predict y-val) l2-loss)))
                (cond ((zero? (modulo epoch 50)) (print "Epoch: " epoch ", Train loss: " train-error ", Validation loss: " val-error)))
                (cond ((< val-error minimum-val-error)
                       (set! minimum-val-error val-error)
                       (set! best-epoch epoch)
                       ((best-model 'set-theta!) ((model 'get-theta)))
                       ))))
            (iota 5000 1))
          (print "----------------------------")
          (let* ((l2-loss (* 0.5 ((best-model 'get-alpha)) (apply + (map (lambda (l) (apply + (map (lambda (x) (* x x)) (cdr l)))) ((best-model 'get-theta))))))
                 (p-train-predict ((best-model 'predict-proba) X-train))
                 (p-val-predict ((best-model 'predict-proba) X-val))
                 (train-error (+ (cross-entropy-error p-train-predict y-train) l2-loss))
                 (val-error (+ (cross-entropy-error p-val-predict y-val) l2-loss)))
            (print "Best epoch: " best-epoch ", Train loss: " train-error ", Validation loss: " val-error)))
        (print "----------------------------")
        (let* ((p-test-predict ((best-model 'predict-proba) X-test))
               (test-error (cross-entropy-error p-test-predict y-test)))
          (print "Test loss: " test-error))))) 0)

